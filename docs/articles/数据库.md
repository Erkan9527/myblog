---
title: 数据库
---


# 数据库相关知识

## NOSQL 和 SQL 的区别

| 特性               | SQL（关系型数据库）                     | NOSQL（非关系型数据库）           |
|--------------------|-----------------------------------------|-----------------------------------|
| **数据模型**        | 表格形式（行和列）                     | 键值对、文档、列族、图等多种模型 |
| **结构化**         | 数据结构固定，需提前定义表结构          | 数据结构灵活，无需预定义          |
| **查询语言**        | 使用 SQL 语言，支持复杂查询             | 无统一查询语言，通常使用 API      |
| **事务支持**        | 完全支持 ACID 特性                     | 一般不支持 ACID，强调最终一致性   |
| **扩展性**         | 垂直扩展（增加硬件资源）                | 水平扩展（增加服务器节点）        |
| **适用场景**        | 结构化数据，事务性强的应用              | 非结构化数据，高并发、大数据场景  |

**示例**:
- **SQL 数据库**: MySQL、PostgreSQL、Oracle、SQL Server
- **NOSQL 数据库**: MongoDB、Redis、Cassandra、HBase


## 数据库三范式

### **第一范式（1NF）**
- **定义**: 数据表的每一列都是不可再分的原子数据项。
- **目的**: 确保数据表中的字段具有原子性。
- **示例**:
  - 不符合 1NF:
    | ID  | 姓名     | 联系方式         |
    |-----|----------|-----------------|
    | 1   | 张三     | 123456, 789012  |
  - 符合 1NF:
    | ID  | 姓名     | 电话号码         |
    |-----|----------|-----------------|
    | 1   | 张三     | 123456          |
    | 1   | 张三     | 789012          |

### **第二范式（2NF）**
- **定义**: 在 1NF 的基础上，确保每个非主属性完全依赖于主键。
- **目的**: 消除部分依赖。
- **示例**:
  - 不符合 2NF:
    | 学号 | 课程   | 成绩 | 学院名称 |
    |------|--------|------|----------|
    | 1    | 数学   | 90   | 理学院   |
  - 符合 2NF:
    - 学生表:
      | 学号 | 学院名称 |
      |------|----------|
      | 1    | 理学院   |
    - 成绩表:
      | 学号 | 课程   | 成绩 |
      |------|--------|------|
      | 1    | 数学   | 90   |

### **第三范式（3NF）**
- **定义**: 在 2NF 的基础上，确保每个非主属性直接依赖于主键，而不是通过其他非主属性间接依赖。
- **目的**: 消除传递依赖。
- **示例**:
  - 不符合 3NF:
    | 学号 | 学院名称 | 学院地址 |
    |------|----------|----------|
    | 1    | 理学院   | 北京     |
  - 符合 3NF:
    - 学生表:
      | 学号 | 学院名称 |
      |------|----------|
      | 1    | 理学院   |
    - 学院表:
      | 学院名称 | 学院地址 |
      |----------|----------|
      | 理学院   | 北京     |


## MySQL 连表查询

### **1. INNER JOIN（内连接）**
- **描述**: 返回两个表中匹配的记录。
- **语法**:
  ```sql
  SELECT A.列名, B.列名
  FROM 表A
  INNER JOIN 表B ON A.列名 = B.列名;
  ```
- **示例**:
  ```sql
  SELECT students.name, courses.course_name
  FROM students
  INNER JOIN courses ON students.course_id = courses.id;
  ```

### **2. LEFT JOIN（左连接）**
- **描述**: 返回左表中的所有记录，以及右表中匹配的记录。
- **语法**:
  ```sql
  SELECT A.列名, B.列名
  FROM 表A
  LEFT JOIN 表B ON A.列名 = B.列名;
  ```
- **示例**:
  ```sql
  SELECT students.name, courses.course_name
  FROM students
  LEFT JOIN courses ON students.course_id = courses.id;
  ```

### **3. RIGHT JOIN（右连接）**
- **描述**: 返回右表中的所有记录，以及左表中匹配的记录。
- **语法**:
  ```sql
  SELECT A.列名, B.列名
  FROM 表A
  RIGHT JOIN 表B ON A.列名 = B.列名;
  ```
- **示例**:
  ```sql
  SELECT students.name, courses.course_name
  FROM students
  RIGHT JOIN courses ON students.course_id = courses.id;
  ```

### **4. FULL JOIN（全连接）**
- **描述**: 返回两个表中的所有记录，匹配的记录会合并。
- **语法**:
  ```sql
  SELECT A.列名, B.列名
  FROM 表A
  FULL JOIN 表B ON A.列名 = B.列名;
  ```
- **示例**:
  ```sql
  SELECT students.name, courses.course_name
  FROM students
  FULL JOIN courses ON students.course_id = courses.id;
  ```



> **总结**:
- **NOSQL 和 SQL**: 适用于不同场景，SQL 强调结构化和事务性，NOSQL 强调灵活性和高并发。
- **数据库三范式**: 通过规范化设计，减少数据冗余，确保数据一致性。
- **MySQL 连表查询**: 掌握 `INNER JOIN`、`LEFT JOIN`、`RIGHT JOIN` 和 `FULL JOIN` 的用法，能够高效查询多表数据。
## Mysql 如何避免重复插入数据
1. **使用唯一约束（UNIQUE）**:
   - 在表的列上添加唯一约束，防止重复数据插入。
   ```sql
   CREATE TABLE users (
       id INT AUTO_INCREMENT PRIMARY KEY,
       email VARCHAR(255) UNIQUE
   );
   ```
2. **使用 `INSERT IGNORE`**:
   - 如果插入的数据违反唯一约束，MySQL 会忽略该条记录。
   ```sql
   INSERT IGNORE INTO users (email) VALUES ('test@example.com');
   ```
3. **使用 `ON DUPLICATE KEY UPDATE`**:
   - 如果插入的数据重复，则更新已有记录。
   ```sql
   INSERT INTO users (id, email) VALUES (1, 'test@example.com')
   ON DUPLICATE KEY UPDATE email = 'test@example.com';
   ```



## varchar 和 char 的区别
- **varchar**:
  - 可变长度字符串，`(n)` 表示最大长度。
  - 节省存储空间，适合长度变化较大的字段。
- **char**:
  - 固定长度字符串，`(n)` 表示固定长度。
  - 性能较高，适合长度固定的字段（如身份证号）。



## int(4) 和 int(5) 在 MySQL 中的区别
- **本质**: `int(4)` 和 `int(5)` 的数字仅影响 **显示宽度**，与存储大小无关。
- **存储大小**: 都占用 4 字节。
- **显示宽度**: 如果设置了 `ZEROFILL`，会在数字前补零。
  ```sql
  CREATE TABLE example (
      id INT(5) ZEROFILL
  );
  INSERT INTO example (id) VALUES (42);
  SELECT id FROM example; -- 输出: 00042
  ```



## 一条 SQL 语句是怎么执行的？
1. **连接器**:
   - 管理客户端连接，验证用户权限。
2. **查询缓存**:
   - 如果查询结果已缓存，直接返回结果。
3. **分析器**:
   - 解析 SQL 语句，检查语法和语义。
4. **优化器**:
   - 生成执行计划，选择最优的查询路径。
5. **执行器**:
   - 根据执行计划调用存储引擎，完成查询操作。



## 数据文件可分为哪几个文件？
1. **数据文件（.ibd 或 .frm）**:
   - 存储表的结构和数据。
2. **日志文件（redo log 和 undo log）**:
   - 用于事务的恢复和回滚。
3. **索引文件**:
   - 存储表的索引信息。
4. **配置文件（my.cnf）**:
   - 数据库的配置参数。


## 主键应该具有什么特征？
1. **唯一性**:
   - 主键值必须唯一，不能重复。
2. **非空性**:
   - 主键列不能包含空值。
3. **稳定性**:
   - 主键值不应频繁修改。
4. **单一性**:
   - 每张表只能有一个主键。
5. **自动增长（可选）**:
   - 主键可以设置为自增字段，便于生成唯一标识。
   ```sql
   CREATE TABLE users (
       id INT AUTO_INCREMENT PRIMARY KEY,
       name VARCHAR(255)
   );
   ```
## B+树的特点
1. **多路平衡树**:
   - B+树是一种多路平衡树，所有叶子节点位于同一层，保证查询性能稳定。
2. **叶子节点存储数据**:
   - 数据只存储在叶子节点，非叶子节点仅存储键值用于索引。
3. **顺序访问指针**:
   - 叶子节点通过指针相连，便于范围查询和顺序遍历。
4. **磁盘友好**:
   - B+树的节点大小与磁盘页大小一致，减少磁盘 I/O 次数。
5. **高效查询**:
   - 支持等值查询、范围查询，时间复杂度为 O(log n)。



## Mysql 为什么不用跳表？
1. **磁盘存储效率**:
   - 跳表是基于链表实现的，随机访问性能较差，而 B+树基于多路平衡树，磁盘 I/O 更少。
2. **范围查询效率**:
   - B+树的叶子节点通过指针相连，支持高效的范围查询，而跳表需要逐层遍历。
3. **成熟性**:
   - B+树在数据库领域应用广泛，算法成熟，性能稳定。
4. **空间利用率**:
   - B+树的节点存储更紧凑，空间利用率高，而跳表需要额外的索引层。



## 说说对联合索引的理解？哪种情况可能会失效？
1. **联合索引**:
   - 联合索引是多个列组成的复合索引，遵循“最左前缀匹配原则”。
   - 示例：`CREATE INDEX idx ON table(col1, col2, col3);`
   
2. **最左前缀匹配原则**:
   - 查询条件必须从索引的最左列开始，才能命中索引。
   - 示例：
     - `WHERE col1 = ?`：命中索引。
     - `WHERE col2 = ?`：索引失效。
     - `WHERE col1 = ? AND col2 = ?`：命中索引。
   
3. **索引失效的情况**:
   - **未使用最左列**: 查询未从最左列开始。
   - **范围查询后续列失效**: 范围查询（`<`、`>`、`BETWEEN`）后，后续列索引失效。
     - 示例：`WHERE col1 > ? AND col2 = ?`，`col2` 索引失效。
   - **函数操作**: 对索引列使用函数。
     - 示例：`WHERE UPPER(col1) = ?`。
   - **隐式类型转换**: 索引列类型与查询条件类型不一致。
     - 示例：`WHERE col1 = '123'`，如果 `col1` 是 INT 类型，索引失效。



## MyBatis 和 MyBatis-Plus 的区别
1. **MyBatis**:
   - **简介**: 一种轻量级的持久层框架，支持自定义 SQL。
   - **特点**:
     - 需要手动编写 SQL。
     - 灵活性高，适合复杂查询。
     - 不提供内置的 CRUD 方法。
   - **适用场景**: 需要高度自定义 SQL 的项目。

2. **MyBatis-Plus**:
   - **简介**: 基于 MyBatis 的增强工具，提供了大量的内置功能。
   - **特点**:
     - 内置 CRUD 方法，减少重复代码。
     - 支持 Lambda 表达式查询。
     - 提供分页插件、逻辑删除等功能。
   - **适用场景**: 需要快速开发、减少 SQL 编写的项目。

3. **对比**:

| 特性               | MyBatis                        | MyBatis-Plus                   |
|--------------------|--------------------------------|--------------------------------|
| **SQL 编写**        | 手动编写 SQL                   | 内置 CRUD 方法，支持自定义 SQL |
| **开发效率**        | 较低                           | 较高                          |
| **功能扩展**        | 无内置扩展                     | 提供分页、逻辑删除等插件       |
| **适用场景**        | 复杂查询、灵活性要求高的场景    | 快速开发、简单业务场景         |

---

> **总结**:
- **B+树**: 是 MySQL 索引的核心数据结构，支持高效的查询和范围操作。
- **跳表**: 虽然简单，但在磁盘存储和范围查询上不如 B+树高效。
- **联合索引**: 遵循最左前缀匹配原则，避免索引失效。
- **MyBatis 与 MyBatis-Plus**: 根据项目需求选择，MyBatis 适合复杂查询，MyBatis-Plus 提高开发效率。
## 如何优化 SQL?

1. **索引优化**:
   - 为查询频繁的字段添加索引（如主键、外键、WHERE 条件字段）。
   - 避免对索引字段使用函数或进行隐式类型转换。
   - 使用覆盖索引，减少回表操作。

2. **减少查询范围**:
   - 使用 `LIMIT` 限制返回结果的数量。
   - 使用分区表，将数据分散到多个分区中，提高查询效率。

3. **避免全表扫描**:
   - 使用索引代替全表扫描。
   - 避免在 WHERE 条件中使用 `LIKE '%xxx'` 或 `OR`。

4. **优化 SQL 语句**:
   - 避免 SELECT *，只查询需要的字段。
   - 合并多条相似的查询，减少数据库交互次数。
   - 使用批量插入或更新，减少事务开销。

5. **缓存查询结果**:
   - 使用 Redis 或 Memcached 缓存热点数据，减少数据库压力。
   - 启用 MySQL 查询缓存（如果适用）。

6. **优化表结构**:
   - 使用合适的数据类型，减少存储空间。
   - 拆分大表（垂直拆分或水平拆分）。

7. **监控和分析**:
   - 使用 `EXPLAIN` 分析查询计划，优化慢查询。
   - 使用 MySQL 的慢查询日志定位性能瓶颈。

---

## Spring 如何做定时任务？在高频获取行情的情况下该怎么做？

### **1. Spring 定时任务的实现方式**
1. **使用 `@Scheduled` 注解**:
   - 配置定时任务，支持 cron 表达式。
   - 示例：
     ```java
     @Scheduled(cron = "0/5 * * * * ?") // 每 5 秒执行一次
     public void fetchMarketData() {
         System.out.println("Fetching market data...");
     }
     ```

2. **使用 `ScheduledExecutorService`**:
   - 基于 JDK 的线程池实现定时任务。
   - 示例：
     ```java
     ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
     executor.scheduleAtFixedRate(() -> {
         System.out.println("Fetching market data...");
     }, 0, 5, TimeUnit.SECONDS);
     ```

3. **使用 `@EnableScheduling`**:
   - 启用 Spring 的定时任务功能。
   - 示例：
     ```java
     @Configuration
     @EnableScheduling
     public class SchedulerConfig {
     }
     ```

4. **使用 Quartz**:
   - 适合复杂的定时任务调度。
   - 示例：
     ```java
     JobDetail job = JobBuilder.newJob(MarketDataJob.class)
         .withIdentity("marketDataJob", "group1")
         .build();
     ```

---

### **2. 高频获取行情的优化方案**
1. **异步处理**:
   - 使用多线程或线程池处理高频任务，避免阻塞主线程。
   - 示例：
     ```java
     @Async
     public void fetchMarketDataAsync() {
         // 异步获取行情数据
     }
     ```

2. **批量处理**:
   - 将多次请求合并为一次批量请求，减少网络开销。
   - 示例：
     ```java
     public void fetchBatchMarketData(List<String> symbols) {
         // 批量获取行情数据
     }
     ```

3. **限流和降级**:
   - 使用限流工具（如 Guava RateLimiter 或 Sentinel）控制请求频率。
   - 示例：
     ```java
     RateLimiter limiter = RateLimiter.create(10); // 每秒最多 10 次请求
     if (limiter.tryAcquire()) {
         fetchMarketData();
     }
     ```

4. **缓存数据**:
   - 使用 Redis 缓存行情数据，减少频繁的网络请求。
   - 示例：
     ```java
     String data = redisTemplate.opsForValue().get("market:data");
     if (data == null) {
         data = fetchMarketData();
         redisTemplate.opsForValue().set("market:data", data, 10, TimeUnit.SECONDS);
     }
     ```

5. **消息队列**:
   - 使用 Kafka 或 RabbitMQ 将行情数据推送到消费者，解耦生产者和消费者。
   - 示例：
     ```java
     kafkaTemplate.send("market-data-topic", marketData);
     ```

6. **分布式任务调度**:
   - 使用分布式任务调度框架（如 Elastic-Job 或 XXL-Job）管理高频任务。
   - 示例：
     ```java
     @ElasticJobConfig(cron = "0/5 * * * * ?", shardingTotalCount = 2)
     public class MarketDataJob implements SimpleJob {
         @Override
         public void execute(ShardingContext context) {
             System.out.println("Fetching market data...");
         }
     }
     ```

---

> **总结**:
- **SQL 优化**: 通过索引优化、减少查询范围、缓存结果等方式提高查询效率。
- **Spring 定时任务**: 提供多种实现方式，适合不同复杂度的任务。
- **高频行情获取**: 结合异步处理、批量请求、缓存、限流等技术，确保系统高效稳定运行。

## 说说你对数据库回滚的理解

1. **定义**:
   - 数据库回滚是指在事务执行过程中，由于某些原因（如错误或异常），将数据库的状态恢复到事务开始之前的状态。
   - 回滚是事务的 ACID 特性（原子性）中的重要组成部分。

2. **作用**:
   - 保证数据的一致性和完整性。
   - 防止错误操作对数据库造成不可逆的影响。

3. **实现方式**:
   - 使用 `ROLLBACK` 语句手动回滚事务。
   - 在事务中发生异常时，数据库会自动回滚未提交的操作。

4. **示例**:
   ```sql
   START TRANSACTION;
   INSERT INTO accounts (id, balance) VALUES (1, 100);
   UPDATE accounts SET balance = balance - 50 WHERE id = 1;
   ROLLBACK; -- 回滚事务，所有操作撤销
   ```

5. **注意事项**:
   - 回滚只能撤销未提交的事务。
   - 一旦事务提交（`COMMIT`），回滚操作无法恢复数据。


## 触发器是什么?

1. **定义**:
   - 触发器（Trigger）是一种特殊的存储程序，当特定的事件（如 `INSERT`、`UPDATE` 或 `DELETE`）在指定表上发生时，自动执行的代码块。

2. **作用**:
   - 实现复杂的业务逻辑。
   - 自动维护数据的完整性和一致性。
   - 记录数据的变更日志。

3. **触发器的类型**:
   - **行级触发器**: 每次操作影响的每一行都会触发。
   - **语句级触发器**: 每次操作触发一次，无论影响多少行。

4. **触发器的事件**:
   - **`BEFORE`**: 在操作执行之前触发。
   - **`AFTER`**: 在操作执行之后触发。

5. **示例**:
   ```sql
   CREATE TRIGGER before_insert_accounts
   BEFORE INSERT ON accounts
   FOR EACH ROW
   BEGIN
       IF NEW.balance < 0 THEN
           SIGNAL SQLSTATE '45000'
           SET MESSAGE_TEXT = 'Balance cannot be negative';
       END IF;
   END;
   ```

6. **注意事项**:
   - 触发器不能直接调用事务控制语句（如 `COMMIT` 或 `ROLLBACK`）。
   - 触发器的执行顺序可能影响性能，应避免复杂的逻辑。



> **总结**:
- **数据库回滚**: 是事务管理的重要功能，用于恢复数据的一致性。
- **触发器**: 是一种自动化机制，用于在特定事件发生时执行预定义的逻辑，适合实现复杂的业务规则。

## 数据库的 redo log 和 undo log 是什么，怎么保证持久性？

### **1. redo log（重做日志）**
- **定义**: 
  - redo log 是 MySQL InnoDB 存储引擎的持久化机制，用于记录事务对数据的修改。
  - 在事务提交前，修改操作会先写入 redo log，确保即使数据库崩溃，数据也能恢复。
- **作用**:
  - 保证事务的 **持久性（Durability）**。
  - 提高写入性能，避免频繁的磁盘 I/O。
- **工作原理**:
  1. 修改数据时，先将操作记录写入 redo log。
  2. redo log 写满后，异步将数据刷新到磁盘。
  3. 数据库崩溃后，通过 redo log 恢复未完成的事务。
- **示例**:
  ```text
  redo log 分为两部分：
  - prepare 阶段：记录事务的修改操作。
  - commit 阶段：标记事务提交。
  ```



### **2. undo log（回滚日志）**
- **定义**:
  - undo log 是 MySQL 用于记录数据修改前的状态，支持事务回滚和 MVCC（多版本并发控制）。
- **作用**:
  - 支持事务的 **原子性（Atomicity）** 和 **一致性（Consistency）**。
  - 实现 MVCC，支持快照读。
- **工作原理**:
  1. 修改数据时，记录修改前的旧值到 undo log。
  2. 事务回滚时，通过 undo log 恢复数据到修改前的状态。
  3. undo log 会在事务提交后被清理（快照读需要时会保留）。
- **示例**:
  ```text
  undo log 主要用于：
  - 回滚事务：撤销未提交的修改。
  - MVCC：实现一致性读。
  ```



### **3. redo log 和 undo log 的区别**

| 特性               | redo log                          | undo log                          |
|--------------------|-----------------------------------|-----------------------------------|
| **作用**            | 保证事务的持久性                 | 支持事务回滚和 MVCC              |
| **记录内容**        | 数据修改后的新值                 | 数据修改前的旧值                 |
| **写入时机**        | 事务修改时立即写入               | 事务修改时记录旧值               |
| **清理时机**        | 数据刷新到磁盘后清理             | 事务提交后清理（部分保留用于 MVCC） |



### **4. 如何保证持久性？**
1. **WAL（Write-Ahead Logging）机制**:
   - 修改数据前，先将操作记录写入 redo log。
   - 确保即使数据库崩溃，数据也能通过 redo log 恢复。

2. **双写机制**:
   - 数据同时写入 redo log 和数据页，防止单点故障导致数据丢失。

3. **刷盘策略**:
   - 使用 `fsync` 将 redo log 刷入磁盘，确保日志持久化。
   - 刷盘策略：
     - **实时刷盘**: 每次事务提交时立即刷盘，安全性高但性能较低。
     - **延迟刷盘**: 定期刷盘，性能较高但可能丢失少量数据。

4. **事务提交机制**:
   - 使用两阶段提交（prepare 和 commit），确保事务的原子性和持久性。



## 怎么做数据库的迁移？

1. **迁移前准备**:
   - **评估需求**: 确定迁移的目标数据库、数据量和业务影响。
   - **备份数据**: 使用工具（如 `mysqldump` 或 `xtrabackup`）备份源数据库。
   - **检查兼容性**: 确保源数据库和目标数据库的版本和配置兼容。

2. **迁移方式**:
   - **逻辑迁移**:
     - 导出数据为 SQL 文件或 CSV 文件。
     - 在目标数据库中导入数据。
     - 示例：
       ```bash
       mysqldump -u root -p source_db > backup.sql
       mysql -u root -p target_db < backup.sql
       ```
   - **物理迁移**:
     - 直接复制数据库文件（如 `.ibd` 文件）。
     - 适合大数据量迁移，速度快。
   - **工具迁移**:
     - 使用专业迁移工具（如 MySQL Workbench、DataX、DTS）。
   - **实时迁移**:
     - 使用数据同步工具（如 Canal、Debezium）实现增量数据迁移。

3. **迁移后验证**:
   - **数据校验**: 比对源数据库和目标数据库的数据一致性。
   - **功能测试**: 验证业务功能是否正常运行。
   - **性能测试**: 检查目标数据库的性能是否满足需求。

4. **注意事项**:
   - **最小化停机时间**: 使用增量迁移工具减少业务中断。
   - **备份与回滚**: 确保迁移失败时可以快速回滚。
   - **权限配置**: 确保目标数据库的用户权限正确配置。



> **总结**:
- **redo log 和 undo log**: redo log 保证事务的持久性，undo log 支持事务回滚和 MVCC。
- **数据库迁移**: 通过逻辑迁移、物理迁移或实时迁移工具，确保数据安全和业务连续性。
## Text 数据类型可以无限大吗？
1. **定义**:
   - `TEXT` 是 MySQL 中用于存储大文本数据的字段类型。
   - 它的大小并不是无限的，而是有明确的存储限制。

2. **存储限制**:
   - `TINYTEXT`: 最大 255 字节。
   - `TEXT`: 最大 65,535 字节（约 64 KB）。
   - `MEDIUMTEXT`: 最大 16,777,215 字节（约 16 MB）。
   - `LONGTEXT`: 最大 4,294,967,295 字节（约 4 GB）。

3. **注意事项**:
   - `TEXT` 类型的字段存储在表外，主表中只存储指针。
   - 超过限制的内容会被截断。



## 说一下外键约束
1. **定义**:
   - 外键约束用于维护表与表之间的关系，确保数据的引用完整性。
   - 外键约束会强制子表中的值必须引用父表中的主键或唯一键。

2. **作用**:
   - 保证数据的一致性和完整性。
   - 防止无效数据插入子表。

3. **语法**:
   ```sql
   CREATE TABLE orders (
       id INT AUTO_INCREMENT PRIMARY KEY,
       user_id INT,
       FOREIGN KEY (user_id) REFERENCES users(id)
   );
   ```

4. **注意事项**:
   - 外键列必须与父表的主键或唯一键类型一致。
   - 外键约束可能影响性能，尤其是在高并发场景下。



## MySQL 为什么 InnoDB 是默认引擎？
1. **事务支持**:
   - InnoDB 支持 ACID 事务，提供更高的数据可靠性。
   - 支持回滚、崩溃恢复等功能。

2. **行级锁**:
   - InnoDB 使用行级锁，支持高并发操作，性能优于 MyISAM 的表级锁。

3. **外键支持**:
   - InnoDB 支持外键约束，保证数据的一致性和完整性。

4. **崩溃恢复**:
   - InnoDB 使用 redo log 和 undo log，支持崩溃后的数据恢复。

5. **默认选择**:
   - 从 MySQL 5.5 开始，InnoDB 成为默认存储引擎，适合大多数应用场景。



## 说一下 MySQL 的 InnoDB 与 MyISAM 的区别
| 特性               | InnoDB                          | MyISAM                          |
|--------------------|----------------------------------|----------------------------------|
| **事务支持**        | 支持 ACID 事务                  | 不支持事务                     |
| **锁机制**         | 行级锁                          | 表级锁                         |
| **外键支持**        | 支持                            | 不支持                         |
| **崩溃恢复**        | 支持                            | 不支持                         |
| **查询性能**        | 写操作性能较高                  | 读操作性能较高                 |
| **适用场景**        | 高并发、事务性强的应用           | 读多写少的场景                 |



## MySQL 可能出现什么和并发相关问题？
1. **死锁**:
   - 多个事务互相等待对方释放锁，导致死锁。
   - **解决方法**: 设置超时时间，合理设计事务顺序。

2. **幻读**:
   - 一个事务在两次查询之间，另一个事务插入了新数据，导致查询结果不一致。
   - **解决方法**: 使用 `REPEATABLE READ` 或 `SERIALIZABLE` 隔离级别。

3. **脏读**:
   - 一个事务读取了另一个未提交事务的数据。
   - **解决方法**: 使用 `READ COMMITTED` 或更高的隔离级别。

4. **不可重复读**:
   - 一个事务在两次查询之间，另一个事务修改了数据，导致查询结果不一致。
   - **解决方法**: 使用 `REPEATABLE READ` 或更高的隔离级别。

5. **更新丢失**:
   - 两个事务同时更新同一条记录，后提交的事务覆盖了先提交的事务。
   - **解决方法**: 使用行级锁或乐观锁。

6. **锁等待**:
   - 一个事务长时间占用锁，导致其他事务无法执行。
   - **解决方法**: 优化事务逻辑，减少锁的持有时间。
## 事务的隔离级别有哪些？

1. **读未提交（Read Uncommitted）**:
   - 一个事务可以读取另一个未提交事务的数据。
   - 存在问题：脏读、不可重复读、幻读。
   - **适用场景**: 几乎不用，数据一致性要求极低的场景。

2. **读已提交（Read Committed）**:
   - 一个事务只能读取另一个事务已提交的数据。
   - 存在问题：不可重复读、幻读。
   - **适用场景**: 大多数数据库的默认隔离级别（如 Oracle）。

3. **可重复读（Repeatable Read）**:
   - 一个事务在整个过程中多次读取同一数据，结果一致。
   - 存在问题：幻读。
   - **适用场景**: MySQL 的默认隔离级别，适合大多数场景。

4. **可串行化（Serializable）**:
   - 所有事务串行执行，避免了脏读、不可重复读和幻读。
   - 存在问题：性能较低，可能导致大量锁等待。
   - **适用场景**: 数据一致性要求极高的场景。



## 这些隔离级别你想怎么排序？

根据事务隔离级别的严格程度，从低到高排序如下：
1. **读未提交（Read Uncommitted）**: 最低级别，允许脏读。
2. **读已提交（Read Committed）**: 防止脏读，但可能出现不可重复读和幻读。
3. **可重复读（Repeatable Read）**: 防止脏读和不可重复读，但可能出现幻读。
4. **可串行化（Serializable）**: 最高级别，完全避免所有问题，但性能最低。



### **总结**
- **隔离级别选择**:
  - 如果性能优先：选择 `Read Committed` 或 `Repeatable Read`。
  - 如果数据一致性优先：选择 `Serializable`。
- **MySQL 默认隔离级别**: `Repeatable Read`，适合大多数场景。
- **Oracle 默认隔离级别**: `Read Committed`，性能和一致性较为平衡。

